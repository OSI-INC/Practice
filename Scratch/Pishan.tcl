

# unix_cmd will take an input file with time stamps from 0
# and will convert these time stamps to unix time based on the file name
# which is the time in GMT
# NOTE I still need to figure out how to convert every file name to unix
proc unix_cmd {args} {
	set scores_unixtime [open scores_unixtime.csv w]
	set start [clock scan "30-Mar-2023 13:57:07 GMT" -format {%d-%b-%Y %H:%M:%S %z}]
	puts $start
	set fn $args
	set f [open $fn r]
	set contents [split [string trim [read $f]] \n]
	set data [lrange $contents 1 end]
	foreach line $data {
		set line [split $line ","]
		set unixclock [expr $start + [lindex $line 0]]
		set line [lreplace $line 0 1 $unixclock]
		lappend unixscores $line
	}
	foreach line $unixscores {
		set line [split $line \n]
		set line [string trim $line "{}"]
		puts $scores_unixtime $line
	} 
	close $scores_unixtime
	
}


# scores_cmd will open one of Pijan's scoring files. It then parses through 
# the contents and creates a new list that has discarded the first line
# of the file, which contains words. 
# The while loop command has a foreach command embedded in it,
# the purpose of which is to generate a value for wake or sleep
# for every second, which is 25 lines of the list. 
# At the end, a new csv file is created with time (generated by the incremented counter)
# and 600 wake or sleep values. A 1 for wake or sleep means that the algorithm
# counter more than 13 "1s" per second.

proc scores_cmd {args} {
			set fn $args
			set f [open $fn r]
			set contents [split [string trim [read $f]] \n]
			set data [lrange $contents 1 end]
			set counter 0
			set f [open pout.csv w]

				while {[llength $data] >= 25} {
					set interval [lrange $data 0 24]
					set data [lrange $data 25 end]
					set wake 0
					set sleep 0
					foreach line $interval {
						set line [split $line "," ]
						if {[lindex $line 3] == 1} {incr wake}
						if {[lindex $line 2] == 1} {incr sleep}
					} 
					if {$wake >= 13} {set wake 1}
					if {$sleep >= 13} {set sleep 1}
					incr counter	
					puts $f "$counter $sleep $wake"
				}
					
			close $f

}
 
# The purpose of the fixtime_cmd is simply to remove the M and .ndf from the unix time stamp
# that represents the unix time at which the eeg/emg values began being recorded.
# It then creates a new list that contains the unix time stamps for each emg/eeg value.
# With this new list, it searches the list for for the time stamp that is equivalent
# to the unix start time of Pijan's scoring file for wake/time. 
# A new list with only the relevant time stamps/ values is generated.
proc fixtime_cmd {args} {
	set o [open npvalues.csv w]
	set fn "$args"
	set f [open $fn r]
	set contents [split [string trim [read $f]] \n]
	set startime 0
	regexp {M([0-9]+)} $contents a b
	foreach val $contents {
		set ftime [expr $b + [lindex $val 1]]
		set val [lreplace $val 0 1 $ftime]
		lappend new $val
	}
	
	set index [lsearch -index 0 $new "1680184627.0"]
	puts $index	
	set final [lrange $new $index end]
	#puts [llength $final]
	puts $o $final
}
	
#match -in process
 
proc match_cmd {scores neuroplayer} {
	set fn1 [open $scores r]
	set fn2 [open $neuroplayer r]
	set r1 [string trim [read $fn1]]
	set r2 [string trim [read $fn2]]
	puts $r2

}
	
		

	

	



while {1} {
	puts -nonewline "Neuroanalysis> "
	flush stdout
	gets stdin ans
	set cmd [lindex $ans 0]
	set args [lrange $ans 1 end]
	if {[catch {
		switch -nocase $cmd {
			"Scores" {
				scores_cmd $args
			}
			"Fixtime" {
				fixtime_cmd $args
			}
			"Unix" {
				unix_cmd $args
			}
			"Match" {
				match_cmd [lindex $args 0] [lindex $args 1]
			}
		}

	} error_message]} {
		puts "ERROR: $error_message"
	}
		
}


#set start [clock scan "30-Mar-2023 13:57:07 GMT" -format {%d-%b-%Y %H:%M:%S %z}]
	
